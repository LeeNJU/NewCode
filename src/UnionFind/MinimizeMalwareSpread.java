package UnionFind;

import java.util.Arrays;
import java.util.stream.IntStream;

//题目描述:给定一个图，用二维数组表示，还有一个初始点集代表被感染的点，这些会感染相邻的节点，如果从初始点集中删除一个点，可以使得被感染的点数最少
//解法描述:union find把节点分组，如果一个分组内有两个及以上的初始点，那么不能移除，因为这些始终会被感染，只有分组内只有一个初始点，并且分组包含的点数最多，这样就可以删除
//       进行分组的时候，需要记录每个分组有多少个节点，以及包含多少个初始节点

public class MinimizeMalwareSpread {

    private int root(int i, int[] vec) {
        while (vec[i] != i) {
            i = vec[i];
        }

        return i;
    }

    private void union(int i, int j, int[] vec, int[] count) {
        int root1 = root(i, vec);
        int root2 = root(j, vec);

        if (root1 != root2) {
            vec[root1] = root2;
            count[root2] += count[root1];
        }
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] vec = new int[n];
        // count表示每个分组包含多少个节点
        int[] count = new int[n];
        Arrays.fill(count, 1);
        IntStream.range(0, n)
                .forEach(i -> vec[i] = i);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1) {
                    union(i, j, vec, count);
                }
            }
        }

        Arrays.sort(initial);

        // 统计每个连通子图中initial感染点的个数
        int[] countAffected = new int[n];
        Arrays.stream(initial)
                .forEach(i -> ++countAffected[root(i, vec)]);

        int numOfRemove = count[root(initial[0], vec)];
        int node = initial[0];
        for (int i = 1; i < initial.length; ++i) {
            int root1 = root(initial[i], vec);
            if (countAffected[root1] == 1 && count[root1] > numOfRemove) {
                numOfRemove = count[root1];
                node = initial[i];
            }
        }

        return node;
    }
}
